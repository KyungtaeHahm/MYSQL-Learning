/*
- 지난 DB원리 때 물류창고랑 비슷하다고 얘기함

- 이 물류창고의 단점은 상충되는 부분 때문에 하나를 선택하면 하나를 포기해야 했음.

- DB를 할 땐 3가지를 동시에 만족해야함

이제 이걸 DB 입장에서 나누면...

READ

1) SQL 쿼리 : SELECT* FROM Accounts(클라 고객) (요청)-> SQL 파싱  - 게임서버 역할

2) SQL 파싱 : (직원)  - 일종의 쓰레드

3) 데이터를 읽고 정보 원하는 정보 전달 (물류창고 & 물건)

4) SQL 파싱 -> 고객(클라) 전달.


WRITE

1) SQL 쿼리 : INSERT...

2) SQL 파싱 

3) 알맞는 곳에 데이터를 덮어쓰기

4) 결과 SQL 파싱-> 클라

----
데이터 쓰기는 가장 오래 걸리는 작업인데, 위와 같을 시 요청 및 요청 후 대기가 오래 걸리는 상황이 발생함

-> 그래서 이를 분리하면 좋지 않을까라는 생각을 하게 됨


---

그래서 데이터베이스에선...

- 많이라는 걸 실천하기 위해서 데이터베이스도 멀티쓰레딩으로 돌아가게 됨.

- 물류창고 [ 물건, 뒤처리/운영전문 (백그라운드 쓰레드)]

- 영업전문 (서버 쓰레드)

이러한 방식으로 구분하게 됨


이러함에도 write할 때 느림. 그래서 알아야 될게 메모리 캐시

[ 메모리 캐시 ]

- 임시창고가 추가됨

- 호텔에 가서 물건을 맡겼더니, 프론트 직원이 자기 뒷자리에 '작은 창고'가 있어서 모든 짐들을 다 우겨 넣고, 그리고 운영하는 애들이 임시창고에서 물건을 꺼내서
옮김.

- read 최적화랑 무슨 관계?

- 메모리 캐시를 활용 할 때는.

1) SQL SELECT를 날렸을 때, 창고에 물건이 있는지 확인하는 게 아니라
2) 임시창고에 물건이 있는지 확인함
3) 결과에 임시창고에 물건이 있다고 하면 바로 클라한테 전달
ㄴ 근데 데이터가 방대해서 물건이 있을까? 라는 의문
 

3) 물건이 없으면
4) 창고가서 READ함 
5) READ 한걸 바로 고객한테 주지 않고 블록 단위 통으로 긁어서 임시창고에 저장하고
6) 고객 클라에게 전달

- 캐시를 통해 READ 속도를 최적화시킴


[인덱스는 어디에 저장되어 있을까? 인덱스가 많아지면 결코 용량이 작지 않기에 ]

- 어떤 데이터가 어디에 있는지 확인하기 위한 용도

- 물류창고에 인덱스용으로 저장되어 있음

1) SQL SELECT
2) SQL 파싱이 인덱스를 사용하면 좋겠다고 판단할 때
3) 임시창고가서 해당 데이터가 있는지 확인
4) 없으면 창고가서 READ INDEX
5) 임시창고가서 저장시킴
6) 고객 클라에게 전달

- 인덱스 정보도 똑같은 데이터로 취급함

- 인덱스를 까봤을 떄 Leaf Page가 아닐 때 복잡해짐...
ㄴ 그러니 인덱스 불렀다고 한번에 뿅 하고 된다고 믿지 말기!


[ 그런데 임시창고가 꽉 찼으면 어떻게 해야하나? ]

- 메모리캐시의 문제 중 하나.

- 주기적 정리 LRU (LEAST RECENTLY USED)를 사용함.
ㄴ 최근에 활용빈도를 기준으로 가장 적은 캐시정보를 정리

- 핵심 내용은 부른다고 무조건 하드를 간다는 건 아니라는 것!

- 임시창고가 해당하는 부품이 뭐지??

ㄴ> 바로 RAM!

RAM에서 접근해서 사용할 수 있으면 양호, HD 까지 가야하면 최악, CPU에서 활용이 끝나면 최고!



*/